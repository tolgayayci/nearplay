{
  "user_id": "3c7bc05c-203c-4df7-a01f-cec5c939a786",
  "project_id": "nft-test-project",
  "code": "use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};\nuse near_sdk::collections::{LazyOption, LookupMap, UnorderedMap, UnorderedSet};\nuse near_sdk::json_types::{Base64VecU8, U128};\nuse near_sdk::serde::{Deserialize, Serialize};\nuse near_sdk::{\n    env, near_bindgen, require, AccountId, Balance, CryptoHash, PanicOnDefault, Promise,\n    PromiseOrValue,\n};\nuse std::collections::HashMap;\n\npub type TokenId = String;\n\n#[derive(BorshSerialize, BorshDeserialize)]\npub struct Token {\n    pub token_id: TokenId,\n    pub owner_id: AccountId,\n}\n\n#[derive(Serialize, Deserialize)]\n#[serde(crate = \"near_sdk::serde\")]\npub struct JsonToken {\n    pub token_id: TokenId,\n    pub owner_id: AccountId,\n    pub metadata: Option<TokenMetadata>,\n}\n\n#[derive(BorshDeserialize, BorshSerialize, Serialize, Deserialize, Clone)]\n#[serde(crate = \"near_sdk::serde\")]\npub struct NFTContractMetadata {\n    pub spec: String,\n    pub name: String,\n    pub symbol: String,\n    pub icon: Option<String>,\n    pub base_uri: Option<String>,\n    pub reference: Option<String>,\n    pub reference_hash: Option<Base64VecU8>,\n}\n\n#[derive(BorshDeserialize, BorshSerialize, Serialize, Deserialize, Clone)]\n#[serde(crate = \"near_sdk::serde\")]\npub struct TokenMetadata {\n    pub title: Option<String>,\n    pub description: Option<String>,\n    pub media: Option<String>,\n    pub media_hash: Option<Base64VecU8>,\n    pub copies: Option<u64>,\n    pub issued_at: Option<String>,\n    pub expires_at: Option<String>,\n    pub starts_at: Option<String>,\n    pub updated_at: Option<String>,\n    pub extra: Option<String>,\n    pub reference: Option<String>,\n    pub reference_hash: Option<Base64VecU8>,\n}\n\n#[near_bindgen]\n#[derive(BorshDeserialize, BorshSerialize, PanicOnDefault)]\npub struct Contract {\n    tokens: UnorderedMap<TokenId, Token>,\n    token_metadata_by_id: UnorderedMap<TokenId, TokenMetadata>,\n    owner_id: AccountId,\n    metadata: LazyOption<NFTContractMetadata>,\n    tokens_per_owner: LookupMap<AccountId, UnorderedSet<TokenId>>,\n    token_approvals_by_id: LookupMap<TokenId, HashMap<AccountId, u64>>,\n    next_approval_id_by_id: LookupMap<TokenId, u64>,\n}\n\n#[near_bindgen]\nimpl Contract {\n    #[init]\n    pub fn new_default_meta(owner_id: AccountId) -> Self {\n        Self::new(\n            owner_id,\n            NFTContractMetadata {\n                spec: \"nft-1.0.0\".to_string(),\n                name: \"Example NFT Contract\".to_string(),\n                symbol: \"EXAMPLE\".to_string(),\n                icon: None,\n                base_uri: None,\n                reference: None,\n                reference_hash: None,\n            },\n        )\n    }\n\n    #[init]\n    pub fn new(owner_id: AccountId, metadata: NFTContractMetadata) -> Self {\n        require!(!env::state_exists(), \"Already initialized\");\n        Self {\n            tokens: UnorderedMap::new(b\"a\".to_vec()),\n            token_metadata_by_id: UnorderedMap::new(b\"b\".to_vec()),\n            owner_id,\n            metadata: LazyOption::new(b\"m\".to_vec(), Some(&metadata)),\n            tokens_per_owner: LookupMap::new(b\"c\".to_vec()),\n            token_approvals_by_id: LookupMap::new(b\"d\".to_vec()),\n            next_approval_id_by_id: LookupMap::new(b\"e\".to_vec()),\n        }\n    }\n\n    pub fn nft_mint(\n        &mut self,\n        token_id: TokenId,\n        receiver_id: AccountId,\n        token_metadata: Option<TokenMetadata>,\n    ) -> Token {\n        let token = Token {\n            token_id: token_id.clone(),\n            owner_id: receiver_id.clone(),\n        };\n\n        self.tokens.insert(&token_id, &token);\n\n        if let Some(metadata) = token_metadata {\n            self.token_metadata_by_id.insert(&token_id, &metadata);\n        }\n\n        let mut tokens_set = self.tokens_per_owner.get(&receiver_id).unwrap_or_else(|| {\n            UnorderedSet::new(format!(\"tokens_per_owner_{}\", receiver_id).as_bytes().to_vec())\n        });\n        tokens_set.insert(&token_id);\n        self.tokens_per_owner.insert(&receiver_id, &tokens_set);\n\n        token\n    }\n\n    pub fn nft_transfer(\n        &mut self,\n        receiver_id: AccountId,\n        token_id: TokenId,\n        approval_id: Option<u64>,\n        memo: Option<String>,\n    ) {\n        // Simple implementation for testing\n    }\n\n    pub fn nft_token(&self, token_id: TokenId) -> Option<JsonToken> {\n        let token = self.tokens.get(&token_id)?;\n        let metadata = self.token_metadata_by_id.get(&token_id);\n\n        Some(JsonToken {\n            token_id,\n            owner_id: token.owner_id,\n            metadata,\n        })\n    }\n\n    pub fn nft_approve(&mut self, token_id: TokenId, account_id: AccountId, msg: Option<String>) {\n        // Implementation for approval\n    }\n\n    pub fn nft_revoke(&mut self, token_id: TokenId, account_id: AccountId) {\n        // Implementation for revoking approval\n    }\n\n    pub fn nft_revoke_all(&mut self, token_id: TokenId) {\n        // Implementation for revoking all approvals\n    }\n\n    pub fn nft_is_approved(&self, token_id: TokenId, approved_account_id: AccountId, approval_id: Option<u64>) -> bool {\n        false // Placeholder\n    }\n\n    pub fn nft_total_supply(&self) -> U128 {\n        U128(self.tokens.len() as u128)\n    }\n\n    pub fn nft_tokens(&self, from_index: Option<U128>, limit: Option<u64>) -> Vec<JsonToken> {\n        vec![] // Placeholder\n    }\n\n    pub fn nft_supply_for_owner(&self, account_id: AccountId) -> U128 {\n        U128(0) // Placeholder\n    }\n\n    pub fn nft_tokens_for_owner(&self, account_id: AccountId, from_index: Option<U128>, limit: Option<u64>) -> Vec<JsonToken> {\n        vec![] // Placeholder\n    }\n\n    pub fn nft_metadata(&self) -> NFTContractMetadata {\n        self.metadata.get().unwrap()\n    }\n}"
}