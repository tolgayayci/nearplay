use anyhow::{Context, Result};
use serde_json::Value;
use std::fs;
use std::path::PathBuf;

/// Extract contract metadata/ABI from compilation artifacts
pub fn extract_contract_metadata(project_path: &PathBuf) -> Result<Value> {
    // Look for ABI file generated by cargo-near
    let abi_file = project_path.join("target").join("near").join("contract_abi.json");
    
    if abi_file.exists() {
        let abi_content = fs::read_to_string(&abi_file)
            .context("Failed to read ABI file")?;
        
        let abi: Value = serde_json::from_str(&abi_content)
            .context("Failed to parse ABI JSON")?;
        
        Ok(abi)
    } else {
        // Generate a basic ABI structure if no ABI file exists
        Ok(generate_basic_abi())
    }
}

/// Generate a basic ABI structure for contracts without explicit ABI
fn generate_basic_abi() -> Value {
    serde_json::json!({
        "schema_version": "0.3.0",
        "metadata": {
            "name": "contract",
            "version": "0.1.0",
            "build": {
                "compiler": "rustc",
                "builder": "cargo-near"
            }
        },
        "body": {
            "functions": [
                {
                    "name": "new",
                    "kind": "call",
                    "params": {
                        "serialization_type": "json",
                        "args": []
                    },
                    "result": {
                        "serialization_type": "json"
                    }
                }
            ]
        }
    })
}

/// Parse Rust code to extract function signatures (basic implementation)
pub fn extract_function_signatures(code: &str) -> Vec<FunctionSignature> {
    let mut signatures = Vec::new();
    
    // This is a simplified parser - in production, you'd use syn crate for proper AST parsing
    for line in code.lines() {
        let trimmed = line.trim();
        if trimmed.starts_with("pub fn ") || trimmed.starts_with("fn ") {
            if let Some(signature) = parse_function_line(trimmed) {
                signatures.push(signature);
            }
        }
    }
    
    signatures
}

#[derive(Debug, Clone)]
pub struct FunctionSignature {
    pub name: String,
    pub is_public: bool,
    pub is_mutable: bool,
    pub parameters: Vec<Parameter>,
    pub return_type: Option<String>,
}

#[derive(Debug, Clone)]
pub struct Parameter {
    pub name: String,
    pub param_type: String,
}

fn parse_function_line(line: &str) -> Option<FunctionSignature> {
    // Very basic function parsing - should be replaced with proper AST parsing
    let is_public = line.contains("pub fn");
    let is_mutable = line.contains("&mut self");
    
    // Extract function name (simplified)
    if let Some(fn_start) = line.find("fn ") {
        let after_fn = &line[fn_start + 3..];
        if let Some(paren_pos) = after_fn.find('(') {
            let name = after_fn[..paren_pos].trim().to_string();
            
            return Some(FunctionSignature {
                name,
                is_public,
                is_mutable,
                parameters: Vec::new(), // TODO: Parse parameters
                return_type: None,      // TODO: Parse return type
            });
        }
    }
    
    None
}

/// Validate NEAR account ID format
pub fn validate_account_id(account_id: &str) -> bool {
    // Basic validation - should match NEAR account ID rules
    if account_id.len() < 2 || account_id.len() > 64 {
        return false;
    }
    
    // Must be lowercase alphanumeric with dots, hyphens, or underscores
    account_id.chars().all(|c| {
        c.is_ascii_lowercase() || c.is_ascii_digit() || c == '.' || c == '-' || c == '_'
    })
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_validate_account_id() {
        assert!(validate_account_id("alice.testnet"));
        assert!(validate_account_id("bob-123.near"));
        assert!(validate_account_id("contract_v1.testnet"));
        
        assert!(!validate_account_id("ALICE.testnet")); // uppercase
        assert!(!validate_account_id("alice@testnet")); // invalid character
        assert!(!validate_account_id("a")); // too short
    }

    #[test]
    fn test_extract_function_signatures() {
        let code = r#"
            pub fn new() -> Self {
                Self { value: 0 }
            }
            
            pub fn get_value(&self) -> u32 {
                self.value
            }
            
            pub fn set_value(&mut self, value: u32) {
                self.value = value;
            }
        "#;
        
        let signatures = extract_function_signatures(code);
        assert_eq!(signatures.len(), 3);
        assert_eq!(signatures[0].name, "new");
        assert_eq!(signatures[1].name, "get_value");
        assert_eq!(signatures[2].name, "set_value");
    }
}